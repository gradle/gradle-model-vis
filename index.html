<!DOCTYPE html>
<meta charset="utf-8">
<style>

svg {
  font-size: 8pt;
  font-family: monospace;
}

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

text {
  stroke: none;
  fill: black;
}

</style>
<body>
<button id="back">â€“</button>
<input id="time" type="range" width="100"/>
<button id="forward">+</button>
<button id="play-pause">&gt;&gt;</button>

<script src="lib/d3.v3.js"></script>
<script src="lib/underscore.js"></script>
<script src="lib/jquery-2.2.0.min.js"></script>
<script>

var width = 1000,
    height = 600;

var color = d3.scale.category20();

var stateColors = {
  Registered: "#aec7e8",
  Discovered: "#1f77b4",
  Created: "#2ca02c",
  DefaultsApplied: "#ffbb78",
  Initialized: "#ff7f0e",
  Mutated: "#d62728",
  Finalized: "#e377c2",
  SelfClosed: "#c7c7c7",
  GraphClosed: "#7f7f7f",
};

var svg = d3.select("body").append("svg")
  .attr("width", width)
  .attr("height", height);

var legend = svg.selectAll(".legend")
  .data(Object.keys(stateColors));

var legendGroup = legend.enter()
    .append("g")
    .attr("class", "legend");

var legendCircle = legendGroup.append("circle")
    .attr("r", 10)
    .attr("cx", 10)
    .attr("cy", function (d, idx) {
      return 10 + idx * 22;
    })
    .attr("fill", function (d) { return stateColors[d]; });

var legendText = legendGroup.append("text")
    .attr("x", 22)
    .attr("y", function (d, idx) {
      return 13 + idx * 22;
    })
    .text(function(d) { return d; });
legend.exit().remove();


var force = d3.layout.force()
  .charge(-120)
  .linkDistance(80)
  .size([width, height]);
var nodes = force.nodes(),
    links = force.links();

var dataFile = location.hash ? location.hash.substring(1) : "samples/gradle-model.json";
console.log("Loading data file", dataFile);

d3.json(dataFile, function(error, events) {
  if (error) throw error;

  var commands = processEvents(events);
  var time = 0;

  $("#time").attr({min: 0, max: events.length}).val(0);
  $("#back").click(function () {
    var value = parseInt($("#time").val());
    value = Math.max(0, value - 1);
    $("#time").val(value);
    $("#time").trigger("input");
  });
  $("#forward").click(function () {
    var value = parseInt($("#time").val());
    value = Math.min(events.length, value + 1);
    $("#time").val(value);
    $("#time").trigger("input");
  });
  var playing = false;
  var $playPause = $("#play-pause");
  $playPause.click(function() {
      var stop = function() {
        playing = false;
        $playPause.text(">>");
      };
      if(!playing) {
      var playLoop = function() {
        var $time = $("#time");
        var cur = parseInt($time.val());
        var max = parseInt($time.attr('max'));
        if(cur<max) {
          $("#forward").trigger("click");
          if(playing) setTimeout(playLoop, 200);
        } else {
          stop();
        }
      };
      playing = true;
      $playPause.text("||");
      playLoop();
    } else {
        stop();
    }
  });

  var redrawUntil = function (targetTime) {
    if (time < targetTime) {
      while (time < targetTime) {
        commands[time].forward();
        time++;
      }
    } else {
      while (time > targetTime) {
        time--;
        commands[time].backward();
      }
    }
    repaint();
  }

  $("#time").on("input", function () {
    redrawUntil($(this).val());
  });

  // redrawUntil(events.length / 2);
});

function repaint() {
  var link = svg.selectAll(".link")
      .data(links);

  link.enter().append("line")
      .attr("class", "link")
      .style("stroke-width", function(d) { return Math.sqrt(d.value); });
  link.exit().remove();

  var node = svg.selectAll(".node")
    .data(nodes);

  var nodeGroup = node.enter()
      .append("g")
      .attr("class", "node");

  var nodeCircle = nodeGroup.append("circle")
      .attr("r", 15)
      .call(force.drag);

  var nodeText = nodeGroup.append("text")
      .text(function(d) { return d.name; })
      .style("fill", "#000000");
  node.exit().remove();

  force.on("tick", function () {
    node
      .style("fill", function(d) {
        return stateColors[d.state];
      });

    node
      .attr("transform", function (d) {
        var transform = "translate(" + d.x + "," + d.y + ")";
        return transform;
      });
    // nodeCircle
    //     .attr("cx", function(d) { return d.x; })
    //     .attr("cy", function(d) { return d.y; });
    // nodeText
    //     .attr("x", function(d) { return d.x; })
    //     .attr("y", function(d) { return d.y; });

    link
      .attr("x1", function (d) {
          return d.source.x;
      })
      .attr("y1", function (d) {
          return d.source.y;
      })
      .attr("x2", function (d) {
          return d.target.x;
      })
      .attr("y2", function (d) {
          return d.target.y;
      });
  });

  // Restart the force layout.
  force
      // .charge(-120)
      // .linkDistance(80)
      // .size([width, height])
      .start();
}

var findNodeIndex = function (path) {
    for (var i = 0; i < nodes.length; i++) {
        if (nodes[i].name == path) {
            return i;
        }
    };
};

// Add and remove elements on the graph object
var addNode = function (path) {
    nodes.push({
      "name": path,
      "state": "Registered"
    });
};

var removeNode = function (path) {
    var i = 0;
    var nodeIndex = findNodeIndex(path);
    var node = nodes[nodeIndex];
    while (i < links.length) {
      var link = links[i];
      if (link.source == node || link.target == node) {
        links.splice(i, 1);
      }
      else {
        i++;
      }
    }
    nodes.splice(nodeIndex, 1);
};

var addLink = function (source, target, value) {
  var sourceIdx = findNodeIndex(source);
  var sourceNode = nodes[sourceIdx];
  if (!sourceNode) {
    throw "No source node for " + source;
  }
  var targetIdx = findNodeIndex(target);
  var targetNode = nodes[targetIdx];
  if (!targetNode) {
    throw "No target node for " + target;
  }
  links.push({"source": sourceNode, "target": targetNode, "value": value});
};

var removeLink = function (source, target) {
    for (var i = 0; i < links.length; i++) {
        if (links[i].source.id == source && links[i].target.id == target) {
            links.splice(i, 1);
            break;
        }
    }
};

var setState = function (path, state) {
  var node = nodes[findNodeIndex(path)];
  node.state = state;
}

function processEvents(events) {
  var existingNodes = {};
  var commands = [];
  events.forEach(function (event) {
    var existingNode = existingNodes[event.path];
    if (existingNode) {
      var nextState = event.state;
      var previousState = existingNode.state;
      commands.push({
        forward: function () {
          console.log("-> " + event.path + " -> " + nextState);
          setState(event.path, nextState);
        },
        backward: function () {
          console.log("<- " + event.path + " -> " + previousState);
          setState(event.path, previousState);
        }
      });
      existingNode.state = event.state;
    } else {
      commands.push({
        forward: function () {
          console.log("++ " + event.path);
          addNode(event.path);
          if (event.path) {
            var idx = event.path.lastIndexOf('.');
            var parentPath = idx === -1 ? "" : event.path.substring(0, idx);
            addLink(event.path, parentPath, 1);
          }
        },
        backward: function () {
          console.log("-- " + event.path);
          removeNode(event.path);
        }
      });
      existingNodes[event.path] = {
        path: event.path,
        state: event.state
      };
    }
  });
  return commands;
}

</script>
